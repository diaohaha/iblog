---
title: 浅析SSL/TSL的通信机制
date: 2021-07-02 16:46:32
tags: SSL,TSL
categories: HTTP
---

`Secure Sockets Layer  安全套接字层
`

`Transport Layer Security  传输层安全
`

TLS是基于SSL3.0之后升级设计的协议，相当于SSL的后续版本。

[信息安全概述](https://diaohaha.github.io/2019/04/20/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7/)中介绍了信息安全中要保证信息的3大特性:保密性（防窃听）、完整性（防篡改）、不可抵赖性（防抵赖）。SSL的设计中对以上特性都进行了考虑，可谓信息安全的集大成者。

<!--more-->

SSL通信的总体思路是使用公钥加密对称密钥，使用对称加密数据。

- 为什么不都使用公钥加密？
`对称加密主要为位运算，而非对称加密都是大数相乘，取模。对CPU压力较大。
`

### SSL握手过程

SSL会话协商的过程如下：

![](http://www.ruanyifeng.com/blogimg/asset/201402/bg2014020502.png)


#### 1.客户端（ClientHello）

首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。请求中包含如下信息。

```
（1） 支持的协议版本，比如TLS 1.0版。

（2） 一个客户端生成的随机数-A，稍后用于生成"对话密钥"。

（3） 支持的加密方法，比如RSA公钥加密。

（4） 支持的压缩方法。
```

#### 2.服务器回应（SeverHello）

服务器的回应包含以下内容。

```
（1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。

（2） 一个服务器生成的随机数-B，稍后用于生成"对话密钥"。

（3） 确认使用的加密方法，比如RSA公钥加密。

（4） 服务器证书。
```

#### 3. 客户端回应

客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。

```
（1） 一个随机数-C。该随机数用服务器公钥加密，防止被窃听。

（2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

（3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。
```

#### 4.服务器的最后回应

服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的"会话密钥"。然后，向客户端最后发送下面信息。

```
（1）编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。
```

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。


SSL整个握手的过程就是协商出一个安全密钥的过程。那么问题来了，如何在不安全的信道上交换一个密钥呢。


### 如何传递密钥

在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？

要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。

DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。

```
我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：

1.甲首选选择一个素数p，例如509，底数g，任选，例如5，随机数a，例如123，然后计算A=g^a mod p，结果是215，然后，甲发送p＝509，g=5，A=215给乙；
2.乙方收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，乙再同时计算s=A^b mod p，结果是121；
3.乙把计算的B=181发给甲，甲计算s＝B^a mod p的余数，计算结果与乙算出的结果一样，都是121。

所以最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。

```

所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。

如果我们把a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥secretKey，DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。


